x<-1
x
print(x)
msg <-"hi"
msg
y
x <- 1:23
x
x <- 1:58
x
x <- a:b
x<-c(T,F)
x
x<-c(5,6)
x
x<-c(1+0i,2+5i)
x
x<-c(1+0i,5.6, 5, T)
x
x,-vector("numeric", length=12)
x<-vector("numeric", length=12)
x
x <-"assss"
x
x<-c(1.7,"a"0
x<-c(1.7,"a")
x
x<-c(1.7,a)
x<-c(T,"a")
x
x<-1:7
class(x)
as.numberic(x)
as.numeric(x)
as.character(x)
as.complex(x)
as.logical(x)
m<-matrix(nrows=3,ncols=3)
m<-matrix(nrow=3,ncol=3)
dim(m)
m
attributes(x)
attributes(m)
m<-matrix(1:6,nrow=3,ncol=3)
m
m<-matrix(1:9,nrow=3,ncol=3)
m
m<-1:12
m
dim(m0
d
dim(m)
dim(m)<-c(3,4)
m
x<-1:3
y<-10:12
cbind(x,y)
y<-10:14
cbind(x,y)
x<-list(1,y,"a")
x
x<-list(1,y,x, "a")
x
q()
x<-factor(c('yes','no','yes','no'))
x
table(x)
levels(x)
unclass(x)
x<-factor(c(1,1,2,2,3,3,3,3,4,5,5,5,5))
table(x)
x<-factor(c(1,1,2,2,3,3,3,3,4,5,5,5,5)),levels=c('one,'two','three','four','five')
x<-factor(c(1,1,2,2,3,3,3,3,4,5,5,5,5)),levels=c('one,'two','three','four','five')
x<-factor(c(1,1,2,2,3,3,3,3,4,5,5,5,5)),levels=5:1
x<-factor(c(1,1,2,2,3,3,3,3,4,5,5,5,5)),levels=c(5,4,3,2,1)
x<-factor(c(1,1,2,2,3,3,3,3,4,5,5,5,5),levels=c('one,'two','three','four','five'))
x<-factor(c(1,1,2,2,3,3,3,3,4,5,5,5,5),levels=c('one','two','three','four','five'))
table(x)
x<-factor(c(1,1,2,2,3,3,3,3,4,5,5,5,5),levels=c(5,4,3,2,1))
table(x)
x<-c(1,2,NA,3,4,5,NA)
x
is.NA(x)
is.na(x)
is.nan(x)
x<-c(1,2,NA,3,4,5,NaN)
x
is.nan(x)
is.na(x)
x<-data.frame(reg=1:4, name=c('imthyaz','sharmila','sarah','tahir'))
x
nrow(x)
nrow(c)
nrow(x)
y
d<-data.matrix(x)
d
x<-data.frame(reg=1:4, name=c('imthyaz','sharmila',NA, NaN))
x
d<-data.matrix(x)
d
x<-data.frame(reg=1:4, name=c('imthyaz','sharmila',na, nan))
x<-data.frame(reg=1:4, name=c('imthyaz','sharmila',NA, nan))
x<-data.frame(reg=1:4, name=c('imthyaz','sharmila',NA, NAN))
x<-data.frame(reg=1:4, name=c('imthyaz','sharmila',NA, NaN))
d<-data.matrix(x)
d
s<- 1:3
s
names(s)
names(s)<-c('f','g','h')
names(s)
s
m<-matrix(1:4,nrow=2,ncol=2)
m
dimnames(m)<-list(c('A','B'),c('C','D'))
m
x<-c(1,2,3,4,5,6)
x
x[1]
x[4]
x[<2]
x[x<2]
x[x>2]
x[2;5]
x[2:5]
u<- x>2
u
x(u)
x[u]
h<-matirx(1:6,4,5)
h<-matrix(1:6,2,3)
h[1:2]
h
h[1,2]
h[1:1]
h[1,]
h[,2]
h[1:2, drop=F}
h[1:2, drop=F]
h[1,2, drop=F]
x<-list(f=1:4,b:.8)
x<-list(f=1:4,b=.8)
x
x[[2]]
x[[1[2]]
dd
x[[1]]
x$b
x$f
x['f']
x[[1]]
z<-list(r=1:5, name=c('A','B','C','D','E'), cgpa=c(1.1,2.2,3.3,4.4,5.5))
z
z[c(1:2)]
z[c(1,3)]
z[[1,3]]
z[[1][3]]
z[[1]]
name<-"cgpa'
x
d;
2
P"
name
name<-"cgpa'
d
'
"
name<-"cgpa"
z[name]
z[[name]]
z$name
z[[1]]
z[[1]][[3]]
z[[3]][[3]]
q()
help(read.table)
q()
x<-c("a","b","c","d")
for(i in 1:4){ print(x[i])}
for(i in seq_along(x)){ print(x[i])}
for(letter in x){ print(letter)}
x<-matrix(1:9, 3,3)
x
for(i in seq_len(nrow(x)))
for(j in seq_len(ncol(x)))
print(x[i,j])
q()
add2 <- function(x,y){
x+y
}
add2(4,5)
add2("fff","ddd")
aboveany <- function(x,n){
use <- x>n
x[use]
}
x<- c(1,2,3,88,77,55,3,2,44,55,3,33,243)
aboveany(x,10)
mm <- function(y){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i]= mean(y[,i])
}
means
}
mm(airquality)
mm <- function(y, removeNA=TRUE){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i]= mean(y[,i], na.rm = removeNA)
}
means
}
mm(airquality)
z,-3
z<-3
x<-function(g,a){}
x<-function(g,a){g+z+a}
x(3,4)
x(1,4)
months
cube <- function(x, n) {
x^3
}
cube(3)
x <- 1:10
if(x > 5) {
x <- 0
}
x
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z<-10
f(3)
x<-5
y <- if(x < 3) {
NA
} else {
10
}
y
y<-2
y
y <- if(x < 3) {
NA
} else {
10
}
y
x <- 1:10
if(x > 5) {
x <- 0
}
git
ls
getwd()
setwd("C:\Users\sharmila\ProgrammingAssignment2")
setwd("C:/Users/sharmila/ProgrammingAssignment2")
ls
cachematrix.R
open cachematrix.R
x$set_inv_matrix(im)
return(im)
get_inv_matrix <- function() im
makeCacheMatrix(1:9,3,3)
makeCacheMatrix
load
load(cachematrix.R)
load(C:/Users/sharmila/ProgrammingAssignment2/cachematrix.R)
load("C:/Users/sharmila/ProgrammingAssignment2/cachematrix.R")
makeCacheMatrix
## Put comments here that give an overall description of what your
## functions do
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
## setting matrix value
im <- NULL
set <- function(y) {
x <<- y
im <<- NULL
}
## getting matrix value
get <- function() x
## setting inverse of matrix
set_inv_matrix <- function(solve) im <<- solve
get_inv_matrix <- function() im
## getting inverse of matrix
list(set = set,
get = get,
set_inv_matrix = set_inv_matrix,
get_inv_matrix = get_inv_matrix)
}
## This function computes the inverse of the special "matrix" returned by makeCacheMatrix
## above. If the inverse has already been calculated (and the matrix has not
##changed), then cacheSolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
## getting inverse of the matrix
im <- x$get_inv_matrix()
## checking if there is the matrix already
if(!is.null(im)) {
message("getting matrix from cache.....")
return(im)
}
else{
## if not in cache , then get the inverse of the matrix
mdata <- x$get()
im <- solve(mdata, ...)
## set the inverse of the matrix
x$set_inv_matrix(im)
return(im)
}
}
makeCacheMatrix(1:9.3.3)
makeCacheMatrix(1:9,3,3)
a<-c(1:9,3,3)
a
a<frame(1:9,3,3)
c<-matrix(1:9,3,3)
makeCacheMatrix(c)
cacheSolve(c)
a <- makeCacheMatrix(matrix(1:4,2))
a$get()
a$getInverse()
a$set(matrix(5:8,2))
a$get()
cacheSolve(a)
cacheSolve(a)
a$getInverse()
b = a$getInverse()
a$get() %*% b
